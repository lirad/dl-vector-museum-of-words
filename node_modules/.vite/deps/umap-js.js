import {
  Matrix,
  init_matrix,
  inverse
} from "./chunk-HANGSSMN.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-PGWBAY6J.js";

// node_modules/umap-js/dist/utils.js
var require_utils = __commonJS({
  "node_modules/umap-js/dist/utils.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reshape2d = exports.rejectionSample = exports.max2d = exports.max = exports.mean = exports.sum = exports.linear = exports.ones = exports.zeros = exports.filled = exports.range = exports.empty = exports.norm = exports.tauRand = exports.tauRandInt = void 0;
    function tauRandInt(n, random) {
      return Math.floor(random() * n);
    }
    exports.tauRandInt = tauRandInt;
    function tauRand(random) {
      return random();
    }
    exports.tauRand = tauRand;
    function norm(vec) {
      var e_1, _a;
      var result = 0;
      try {
        for (var vec_1 = __values(vec), vec_1_1 = vec_1.next(); !vec_1_1.done; vec_1_1 = vec_1.next()) {
          var item = vec_1_1.value;
          result += Math.pow(item, 2);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (vec_1_1 && !vec_1_1.done && (_a = vec_1.return))
            _a.call(vec_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return Math.sqrt(result);
    }
    exports.norm = norm;
    function empty(n) {
      var output = [];
      for (var i = 0; i < n; i++) {
        output.push(void 0);
      }
      return output;
    }
    exports.empty = empty;
    function range(n) {
      return empty(n).map(function(_, i) {
        return i;
      });
    }
    exports.range = range;
    function filled(n, v) {
      return empty(n).map(function() {
        return v;
      });
    }
    exports.filled = filled;
    function zeros(n) {
      return filled(n, 0);
    }
    exports.zeros = zeros;
    function ones(n) {
      return filled(n, 1);
    }
    exports.ones = ones;
    function linear(a, b, len) {
      return empty(len).map(function(_, i) {
        return a + i * ((b - a) / (len - 1));
      });
    }
    exports.linear = linear;
    function sum(input) {
      return input.reduce(function(sum2, val) {
        return sum2 + val;
      });
    }
    exports.sum = sum;
    function mean(input) {
      return sum(input) / input.length;
    }
    exports.mean = mean;
    function max(input) {
      var max2 = 0;
      for (var i = 0; i < input.length; i++) {
        max2 = input[i] > max2 ? input[i] : max2;
      }
      return max2;
    }
    exports.max = max;
    function max2d(input) {
      var max2 = 0;
      for (var i = 0; i < input.length; i++) {
        for (var j = 0; j < input[i].length; j++) {
          max2 = input[i][j] > max2 ? input[i][j] : max2;
        }
      }
      return max2;
    }
    exports.max2d = max2d;
    function rejectionSample(nSamples, poolSize, random) {
      var result = zeros(nSamples);
      for (var i = 0; i < nSamples; i++) {
        var rejectSample = true;
        while (rejectSample) {
          var j = tauRandInt(poolSize, random);
          var broken = false;
          for (var k = 0; k < i; k++) {
            if (j === result[k]) {
              broken = true;
              break;
            }
          }
          if (!broken) {
            rejectSample = false;
          }
          result[i] = j;
        }
      }
      return result;
    }
    exports.rejectionSample = rejectionSample;
    function reshape2d(x, a, b) {
      var rows = [];
      var count = 0;
      var index = 0;
      if (x.length !== a * b) {
        throw new Error("Array dimensions must match input length.");
      }
      for (var i = 0; i < a; i++) {
        var col = [];
        for (var j = 0; j < b; j++) {
          col.push(x[index]);
          index += 1;
        }
        rows.push(col);
        count += 1;
      }
      return rows;
    }
    exports.reshape2d = reshape2d;
  }
});

// node_modules/umap-js/dist/heap.js
var require_heap = __commonJS({
  "node_modules/umap-js/dist/heap.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.smallestFlagged = exports.deheapSort = exports.buildCandidates = exports.uncheckedHeapPush = exports.heapPush = exports.rejectionSample = exports.makeHeap = void 0;
    var utils = __importStar(require_utils());
    function makeHeap(nPoints, size) {
      var makeArrays = function(fillValue) {
        return utils.empty(nPoints).map(function() {
          return utils.filled(size, fillValue);
        });
      };
      var heap = [];
      heap.push(makeArrays(-1));
      heap.push(makeArrays(Infinity));
      heap.push(makeArrays(0));
      return heap;
    }
    exports.makeHeap = makeHeap;
    function rejectionSample(nSamples, poolSize, random) {
      var result = utils.zeros(nSamples);
      for (var i = 0; i < nSamples; i++) {
        var rejectSample = true;
        var j = 0;
        while (rejectSample) {
          j = utils.tauRandInt(poolSize, random);
          var broken = false;
          for (var k = 0; k < i; k++) {
            if (j === result[k]) {
              broken = true;
              break;
            }
          }
          if (!broken)
            rejectSample = false;
        }
        result[i] = j;
      }
      return result;
    }
    exports.rejectionSample = rejectionSample;
    function heapPush(heap, row, weight, index, flag) {
      row = Math.floor(row);
      var indices = heap[0][row];
      var weights = heap[1][row];
      var isNew = heap[2][row];
      if (weight >= weights[0]) {
        return 0;
      }
      for (var i = 0; i < indices.length; i++) {
        if (index === indices[i]) {
          return 0;
        }
      }
      return uncheckedHeapPush(heap, row, weight, index, flag);
    }
    exports.heapPush = heapPush;
    function uncheckedHeapPush(heap, row, weight, index, flag) {
      var indices = heap[0][row];
      var weights = heap[1][row];
      var isNew = heap[2][row];
      if (weight >= weights[0]) {
        return 0;
      }
      weights[0] = weight;
      indices[0] = index;
      isNew[0] = flag;
      var i = 0;
      var iSwap = 0;
      while (true) {
        var ic1 = 2 * i + 1;
        var ic2 = ic1 + 1;
        var heapShape2 = heap[0][0].length;
        if (ic1 >= heapShape2) {
          break;
        } else if (ic2 >= heapShape2) {
          if (weights[ic1] > weight) {
            iSwap = ic1;
          } else {
            break;
          }
        } else if (weights[ic1] >= weights[ic2]) {
          if (weight < weights[ic1]) {
            iSwap = ic1;
          } else {
            break;
          }
        } else {
          if (weight < weights[ic2]) {
            iSwap = ic2;
          } else {
            break;
          }
        }
        weights[i] = weights[iSwap];
        indices[i] = indices[iSwap];
        isNew[i] = isNew[iSwap];
        i = iSwap;
      }
      weights[i] = weight;
      indices[i] = index;
      isNew[i] = flag;
      return 1;
    }
    exports.uncheckedHeapPush = uncheckedHeapPush;
    function buildCandidates(currentGraph, nVertices, nNeighbors, maxCandidates, random) {
      var candidateNeighbors = makeHeap(nVertices, maxCandidates);
      for (var i = 0; i < nVertices; i++) {
        for (var j = 0; j < nNeighbors; j++) {
          if (currentGraph[0][i][j] < 0) {
            continue;
          }
          var idx = currentGraph[0][i][j];
          var isn = currentGraph[2][i][j];
          var d = utils.tauRand(random);
          heapPush(candidateNeighbors, i, d, idx, isn);
          heapPush(candidateNeighbors, idx, d, i, isn);
          currentGraph[2][i][j] = 0;
        }
      }
      return candidateNeighbors;
    }
    exports.buildCandidates = buildCandidates;
    function deheapSort(heap) {
      var indices = heap[0];
      var weights = heap[1];
      for (var i = 0; i < indices.length; i++) {
        var indHeap = indices[i];
        var distHeap = weights[i];
        for (var j = 0; j < indHeap.length - 1; j++) {
          var indHeapIndex = indHeap.length - j - 1;
          var distHeapIndex = distHeap.length - j - 1;
          var temp1 = indHeap[0];
          indHeap[0] = indHeap[indHeapIndex];
          indHeap[indHeapIndex] = temp1;
          var temp2 = distHeap[0];
          distHeap[0] = distHeap[distHeapIndex];
          distHeap[distHeapIndex] = temp2;
          siftDown(distHeap, indHeap, distHeapIndex, 0);
        }
      }
      return { indices, weights };
    }
    exports.deheapSort = deheapSort;
    function siftDown(heap1, heap2, ceiling, elt) {
      while (elt * 2 + 1 < ceiling) {
        var leftChild = elt * 2 + 1;
        var rightChild = leftChild + 1;
        var swap = elt;
        if (heap1[swap] < heap1[leftChild]) {
          swap = leftChild;
        }
        if (rightChild < ceiling && heap1[swap] < heap1[rightChild]) {
          swap = rightChild;
        }
        if (swap === elt) {
          break;
        } else {
          var temp1 = heap1[elt];
          heap1[elt] = heap1[swap];
          heap1[swap] = temp1;
          var temp2 = heap2[elt];
          heap2[elt] = heap2[swap];
          heap2[swap] = temp2;
          elt = swap;
        }
      }
    }
    function smallestFlagged(heap, row) {
      var ind = heap[0][row];
      var dist = heap[1][row];
      var flag = heap[2][row];
      var minDist = Infinity;
      var resultIndex = -1;
      for (var i = 0; i > ind.length; i++) {
        if (flag[i] === 1 && dist[i] < minDist) {
          minDist = dist[i];
          resultIndex = i;
        }
      }
      if (resultIndex >= 0) {
        flag[resultIndex] = 0;
        return Math.floor(ind[resultIndex]);
      } else {
        return -1;
      }
    }
    exports.smallestFlagged = smallestFlagged;
  }
});

// node_modules/umap-js/dist/matrix.js
var require_matrix = __commonJS({
  "node_modules/umap-js/dist/matrix.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCSR = exports.normalize = exports.eliminateZeros = exports.multiplyScalar = exports.maximum = exports.subtract = exports.add = exports.pairwiseMultiply = exports.identity = exports.transpose = exports.SparseMatrix = void 0;
    var utils = __importStar(require_utils());
    var SparseMatrix = function() {
      function SparseMatrix2(rows, cols, values, dims) {
        this.entries = /* @__PURE__ */ new Map();
        this.nRows = 0;
        this.nCols = 0;
        if (rows.length !== cols.length || rows.length !== values.length) {
          throw new Error("rows, cols and values arrays must all have the same length");
        }
        this.nRows = dims[0];
        this.nCols = dims[1];
        for (var i = 0; i < values.length; i++) {
          var row = rows[i];
          var col = cols[i];
          this.checkDims(row, col);
          var key = this.makeKey(row, col);
          this.entries.set(key, { value: values[i], row, col });
        }
      }
      SparseMatrix2.prototype.makeKey = function(row, col) {
        return row + ":" + col;
      };
      SparseMatrix2.prototype.checkDims = function(row, col) {
        var withinBounds = row < this.nRows && col < this.nCols;
        if (!withinBounds) {
          throw new Error("row and/or col specified outside of matrix dimensions");
        }
      };
      SparseMatrix2.prototype.set = function(row, col, value) {
        this.checkDims(row, col);
        var key = this.makeKey(row, col);
        if (!this.entries.has(key)) {
          this.entries.set(key, { value, row, col });
        } else {
          this.entries.get(key).value = value;
        }
      };
      SparseMatrix2.prototype.get = function(row, col, defaultValue) {
        if (defaultValue === void 0) {
          defaultValue = 0;
        }
        this.checkDims(row, col);
        var key = this.makeKey(row, col);
        if (this.entries.has(key)) {
          return this.entries.get(key).value;
        } else {
          return defaultValue;
        }
      };
      SparseMatrix2.prototype.getAll = function(ordered) {
        if (ordered === void 0) {
          ordered = true;
        }
        var rowColValues = [];
        this.entries.forEach(function(value) {
          rowColValues.push(value);
        });
        if (ordered) {
          rowColValues.sort(function(a, b) {
            if (a.row === b.row) {
              return a.col - b.col;
            } else {
              return a.row - b.row;
            }
          });
        }
        return rowColValues;
      };
      SparseMatrix2.prototype.getDims = function() {
        return [this.nRows, this.nCols];
      };
      SparseMatrix2.prototype.getRows = function() {
        return Array.from(this.entries, function(_a2) {
          var _b = __read(_a2, 2), key = _b[0], value = _b[1];
          return value.row;
        });
      };
      SparseMatrix2.prototype.getCols = function() {
        return Array.from(this.entries, function(_a2) {
          var _b = __read(_a2, 2), key = _b[0], value = _b[1];
          return value.col;
        });
      };
      SparseMatrix2.prototype.getValues = function() {
        return Array.from(this.entries, function(_a2) {
          var _b = __read(_a2, 2), key = _b[0], value = _b[1];
          return value.value;
        });
      };
      SparseMatrix2.prototype.forEach = function(fn) {
        this.entries.forEach(function(value) {
          return fn(value.value, value.row, value.col);
        });
      };
      SparseMatrix2.prototype.map = function(fn) {
        var vals = [];
        this.entries.forEach(function(value) {
          vals.push(fn(value.value, value.row, value.col));
        });
        var dims = [this.nRows, this.nCols];
        return new SparseMatrix2(this.getRows(), this.getCols(), vals, dims);
      };
      SparseMatrix2.prototype.toArray = function() {
        var _this = this;
        var rows = utils.empty(this.nRows);
        var output = rows.map(function() {
          return utils.zeros(_this.nCols);
        });
        this.entries.forEach(function(value) {
          output[value.row][value.col] = value.value;
        });
        return output;
      };
      return SparseMatrix2;
    }();
    exports.SparseMatrix = SparseMatrix;
    function transpose(matrix) {
      var cols = [];
      var rows = [];
      var vals = [];
      matrix.forEach(function(value, row, col) {
        cols.push(row);
        rows.push(col);
        vals.push(value);
      });
      var dims = [matrix.nCols, matrix.nRows];
      return new SparseMatrix(rows, cols, vals, dims);
    }
    exports.transpose = transpose;
    function identity(size) {
      var _a2 = __read(size, 1), rows = _a2[0];
      var matrix = new SparseMatrix([], [], [], size);
      for (var i = 0; i < rows; i++) {
        matrix.set(i, i, 1);
      }
      return matrix;
    }
    exports.identity = identity;
    function pairwiseMultiply(a, b) {
      return elementWise(a, b, function(x, y) {
        return x * y;
      });
    }
    exports.pairwiseMultiply = pairwiseMultiply;
    function add(a, b) {
      return elementWise(a, b, function(x, y) {
        return x + y;
      });
    }
    exports.add = add;
    function subtract(a, b) {
      return elementWise(a, b, function(x, y) {
        return x - y;
      });
    }
    exports.subtract = subtract;
    function maximum(a, b) {
      return elementWise(a, b, function(x, y) {
        return x > y ? x : y;
      });
    }
    exports.maximum = maximum;
    function multiplyScalar(a, scalar) {
      return a.map(function(value) {
        return value * scalar;
      });
    }
    exports.multiplyScalar = multiplyScalar;
    function eliminateZeros(m) {
      var zeroIndices = /* @__PURE__ */ new Set();
      var values = m.getValues();
      var rows = m.getRows();
      var cols = m.getCols();
      for (var i = 0; i < values.length; i++) {
        if (values[i] === 0) {
          zeroIndices.add(i);
        }
      }
      var removeByZeroIndex = function(_, index) {
        return !zeroIndices.has(index);
      };
      var nextValues = values.filter(removeByZeroIndex);
      var nextRows = rows.filter(removeByZeroIndex);
      var nextCols = cols.filter(removeByZeroIndex);
      return new SparseMatrix(nextRows, nextCols, nextValues, m.getDims());
    }
    exports.eliminateZeros = eliminateZeros;
    function normalize(m, normType) {
      var e_1, _a2;
      if (normType === void 0) {
        normType = "l2";
      }
      var normFn = normFns[normType];
      var colsByRow = /* @__PURE__ */ new Map();
      m.forEach(function(_, row2, col) {
        var cols = colsByRow.get(row2) || [];
        cols.push(col);
        colsByRow.set(row2, cols);
      });
      var nextMatrix = new SparseMatrix([], [], [], m.getDims());
      var _loop_1 = function(row2) {
        var cols = colsByRow.get(row2).sort();
        var vals = cols.map(function(col) {
          return m.get(row2, col);
        });
        var norm = normFn(vals);
        for (var i = 0; i < norm.length; i++) {
          nextMatrix.set(row2, cols[i], norm[i]);
        }
      };
      try {
        for (var _b = __values(colsByRow.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
          var row = _c.value;
          _loop_1(row);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return nextMatrix;
    }
    exports.normalize = normalize;
    var normFns = (_a = {}, _a["max"] = function(xs) {
      var max = -Infinity;
      for (var i = 0; i < xs.length; i++) {
        max = xs[i] > max ? xs[i] : max;
      }
      return xs.map(function(x) {
        return x / max;
      });
    }, _a["l1"] = function(xs) {
      var sum = 0;
      for (var i = 0; i < xs.length; i++) {
        sum += xs[i];
      }
      return xs.map(function(x) {
        return x / sum;
      });
    }, _a["l2"] = function(xs) {
      var sum = 0;
      for (var i = 0; i < xs.length; i++) {
        sum += Math.pow(xs[i], 2);
      }
      return xs.map(function(x) {
        return Math.sqrt(Math.pow(x, 2) / sum);
      });
    }, _a);
    function elementWise(a, b, op) {
      var visited = /* @__PURE__ */ new Set();
      var rows = [];
      var cols = [];
      var vals = [];
      var operate = function(row2, col2) {
        rows.push(row2);
        cols.push(col2);
        var nextValue = op(a.get(row2, col2), b.get(row2, col2));
        vals.push(nextValue);
      };
      var valuesA = a.getValues();
      var rowsA = a.getRows();
      var colsA = a.getCols();
      for (var i = 0; i < valuesA.length; i++) {
        var row = rowsA[i];
        var col = colsA[i];
        var key = row + ":" + col;
        visited.add(key);
        operate(row, col);
      }
      var valuesB = b.getValues();
      var rowsB = b.getRows();
      var colsB = b.getCols();
      for (var i = 0; i < valuesB.length; i++) {
        var row = rowsB[i];
        var col = colsB[i];
        var key = row + ":" + col;
        if (visited.has(key))
          continue;
        operate(row, col);
      }
      var dims = [a.nRows, a.nCols];
      return new SparseMatrix(rows, cols, vals, dims);
    }
    function getCSR(x) {
      var entries = [];
      x.forEach(function(value2, row2, col2) {
        entries.push({ value: value2, row: row2, col: col2 });
      });
      entries.sort(function(a, b) {
        if (a.row === b.row) {
          return a.col - b.col;
        } else {
          return a.row - b.row;
        }
      });
      var indices = [];
      var values = [];
      var indptr = [];
      var currentRow = -1;
      for (var i = 0; i < entries.length; i++) {
        var _a2 = entries[i], row = _a2.row, col = _a2.col, value = _a2.value;
        if (row !== currentRow) {
          currentRow = row;
          indptr.push(i);
        }
        indices.push(col);
        values.push(value);
      }
      return { indices, values, indptr };
    }
    exports.getCSR = getCSR;
  }
});

// node_modules/umap-js/dist/tree.js
var require_tree = __commonJS({
  "node_modules/umap-js/dist/tree.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spread = exports && exports.__spread || function() {
      for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.searchFlatTree = exports.makeLeafArray = exports.makeForest = exports.FlatTree = void 0;
    var utils = __importStar(require_utils());
    var FlatTree = function() {
      function FlatTree2(hyperplanes, offsets, children, indices) {
        this.hyperplanes = hyperplanes;
        this.offsets = offsets;
        this.children = children;
        this.indices = indices;
      }
      return FlatTree2;
    }();
    exports.FlatTree = FlatTree;
    function makeForest(data, nNeighbors, nTrees, random) {
      var leafSize = Math.max(10, nNeighbors);
      var trees = utils.range(nTrees).map(function(_, i) {
        return makeTree(data, leafSize, i, random);
      });
      var forest = trees.map(function(tree) {
        return flattenTree(tree, leafSize);
      });
      return forest;
    }
    exports.makeForest = makeForest;
    function makeTree(data, leafSize, n, random) {
      if (leafSize === void 0) {
        leafSize = 30;
      }
      var indices = utils.range(data.length);
      var tree = makeEuclideanTree(data, indices, leafSize, n, random);
      return tree;
    }
    function makeEuclideanTree(data, indices, leafSize, q, random) {
      if (leafSize === void 0) {
        leafSize = 30;
      }
      if (indices.length > leafSize) {
        var splitResults = euclideanRandomProjectionSplit(data, indices, random);
        var indicesLeft = splitResults.indicesLeft, indicesRight = splitResults.indicesRight, hyperplane = splitResults.hyperplane, offset = splitResults.offset;
        var leftChild = makeEuclideanTree(data, indicesLeft, leafSize, q + 1, random);
        var rightChild = makeEuclideanTree(data, indicesRight, leafSize, q + 1, random);
        var node = { leftChild, rightChild, isLeaf: false, hyperplane, offset };
        return node;
      } else {
        var node = { indices, isLeaf: true };
        return node;
      }
    }
    function euclideanRandomProjectionSplit(data, indices, random) {
      var dim = data[0].length;
      var leftIndex = utils.tauRandInt(indices.length, random);
      var rightIndex = utils.tauRandInt(indices.length, random);
      rightIndex += leftIndex === rightIndex ? 1 : 0;
      rightIndex = rightIndex % indices.length;
      var left = indices[leftIndex];
      var right = indices[rightIndex];
      var hyperplaneOffset = 0;
      var hyperplaneVector = utils.zeros(dim);
      for (var i = 0; i < hyperplaneVector.length; i++) {
        hyperplaneVector[i] = data[left][i] - data[right][i];
        hyperplaneOffset -= hyperplaneVector[i] * (data[left][i] + data[right][i]) / 2;
      }
      var nLeft = 0;
      var nRight = 0;
      var side = utils.zeros(indices.length);
      for (var i = 0; i < indices.length; i++) {
        var margin = hyperplaneOffset;
        for (var d = 0; d < dim; d++) {
          margin += hyperplaneVector[d] * data[indices[i]][d];
        }
        if (margin === 0) {
          side[i] = utils.tauRandInt(2, random);
          if (side[i] === 0) {
            nLeft += 1;
          } else {
            nRight += 1;
          }
        } else if (margin > 0) {
          side[i] = 0;
          nLeft += 1;
        } else {
          side[i] = 1;
          nRight += 1;
        }
      }
      var indicesLeft = utils.zeros(nLeft);
      var indicesRight = utils.zeros(nRight);
      nLeft = 0;
      nRight = 0;
      for (var i = 0; i < side.length; i++) {
        if (side[i] === 0) {
          indicesLeft[nLeft] = indices[i];
          nLeft += 1;
        } else {
          indicesRight[nRight] = indices[i];
          nRight += 1;
        }
      }
      return {
        indicesLeft,
        indicesRight,
        hyperplane: hyperplaneVector,
        offset: hyperplaneOffset
      };
    }
    function flattenTree(tree, leafSize) {
      var nNodes = numNodes(tree);
      var nLeaves = numLeaves(tree);
      var hyperplanes = utils.range(nNodes).map(function() {
        return utils.zeros(tree.hyperplane ? tree.hyperplane.length : 0);
      });
      var offsets = utils.zeros(nNodes);
      var children = utils.range(nNodes).map(function() {
        return [-1, -1];
      });
      var indices = utils.range(nLeaves).map(function() {
        return utils.range(leafSize).map(function() {
          return -1;
        });
      });
      recursiveFlatten(tree, hyperplanes, offsets, children, indices, 0, 0);
      return new FlatTree(hyperplanes, offsets, children, indices);
    }
    function recursiveFlatten(tree, hyperplanes, offsets, children, indices, nodeNum, leafNum) {
      var _a;
      if (tree.isLeaf) {
        children[nodeNum][0] = -leafNum;
        (_a = indices[leafNum]).splice.apply(_a, __spread([0, tree.indices.length], tree.indices));
        leafNum += 1;
        return { nodeNum, leafNum };
      } else {
        hyperplanes[nodeNum] = tree.hyperplane;
        offsets[nodeNum] = tree.offset;
        children[nodeNum][0] = nodeNum + 1;
        var oldNodeNum = nodeNum;
        var res = recursiveFlatten(tree.leftChild, hyperplanes, offsets, children, indices, nodeNum + 1, leafNum);
        nodeNum = res.nodeNum;
        leafNum = res.leafNum;
        children[oldNodeNum][1] = nodeNum + 1;
        res = recursiveFlatten(tree.rightChild, hyperplanes, offsets, children, indices, nodeNum + 1, leafNum);
        return { nodeNum: res.nodeNum, leafNum: res.leafNum };
      }
    }
    function numNodes(tree) {
      if (tree.isLeaf) {
        return 1;
      } else {
        return 1 + numNodes(tree.leftChild) + numNodes(tree.rightChild);
      }
    }
    function numLeaves(tree) {
      if (tree.isLeaf) {
        return 1;
      } else {
        return numLeaves(tree.leftChild) + numLeaves(tree.rightChild);
      }
    }
    function makeLeafArray(rpForest) {
      var e_1, _a;
      if (rpForest.length > 0) {
        var output = [];
        try {
          for (var rpForest_1 = __values(rpForest), rpForest_1_1 = rpForest_1.next(); !rpForest_1_1.done; rpForest_1_1 = rpForest_1.next()) {
            var tree = rpForest_1_1.value;
            output.push.apply(output, __spread(tree.indices));
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (rpForest_1_1 && !rpForest_1_1.done && (_a = rpForest_1.return))
              _a.call(rpForest_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return output;
      } else {
        return [[-1]];
      }
    }
    exports.makeLeafArray = makeLeafArray;
    function selectSide(hyperplane, offset, point, random) {
      var margin = offset;
      for (var d = 0; d < point.length; d++) {
        margin += hyperplane[d] * point[d];
      }
      if (margin === 0) {
        var side = utils.tauRandInt(2, random);
        return side;
      } else if (margin > 0) {
        return 0;
      } else {
        return 1;
      }
    }
    function searchFlatTree(point, tree, random) {
      var node = 0;
      while (tree.children[node][0] > 0) {
        var side = selectSide(tree.hyperplanes[node], tree.offsets[node], point, random);
        if (side === 0) {
          node = tree.children[node][0];
        } else {
          node = tree.children[node][1];
        }
      }
      var index = -1 * tree.children[node][0];
      return tree.indices[index];
    }
    exports.searchFlatTree = searchFlatTree;
  }
});

// node_modules/umap-js/dist/nn_descent.js
var require_nn_descent = __commonJS({
  "node_modules/umap-js/dist/nn_descent.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.initializeSearch = exports.makeInitializedNNSearch = exports.makeInitializations = exports.makeNNDescent = void 0;
    var heap = __importStar(require_heap());
    var matrix = __importStar(require_matrix());
    var tree = __importStar(require_tree());
    var utils = __importStar(require_utils());
    function makeNNDescent(distanceFn, random) {
      return function nNDescent(data, leafArray, nNeighbors, nIters, maxCandidates, delta, rho, rpTreeInit) {
        if (nIters === void 0) {
          nIters = 10;
        }
        if (maxCandidates === void 0) {
          maxCandidates = 50;
        }
        if (delta === void 0) {
          delta = 1e-3;
        }
        if (rho === void 0) {
          rho = 0.5;
        }
        if (rpTreeInit === void 0) {
          rpTreeInit = true;
        }
        var nVertices = data.length;
        var currentGraph = heap.makeHeap(data.length, nNeighbors);
        for (var i = 0; i < data.length; i++) {
          var indices = heap.rejectionSample(nNeighbors, data.length, random);
          for (var j = 0; j < indices.length; j++) {
            var d = distanceFn(data[i], data[indices[j]]);
            heap.heapPush(currentGraph, i, d, indices[j], 1);
            heap.heapPush(currentGraph, indices[j], d, i, 1);
          }
        }
        if (rpTreeInit) {
          for (var n = 0; n < leafArray.length; n++) {
            for (var i = 0; i < leafArray[n].length; i++) {
              if (leafArray[n][i] < 0) {
                break;
              }
              for (var j = i + 1; j < leafArray[n].length; j++) {
                if (leafArray[n][j] < 0) {
                  break;
                }
                var d = distanceFn(data[leafArray[n][i]], data[leafArray[n][j]]);
                heap.heapPush(currentGraph, leafArray[n][i], d, leafArray[n][j], 1);
                heap.heapPush(currentGraph, leafArray[n][j], d, leafArray[n][i], 1);
              }
            }
          }
        }
        for (var n = 0; n < nIters; n++) {
          var candidateNeighbors = heap.buildCandidates(currentGraph, nVertices, nNeighbors, maxCandidates, random);
          var c = 0;
          for (var i = 0; i < nVertices; i++) {
            for (var j = 0; j < maxCandidates; j++) {
              var p = Math.floor(candidateNeighbors[0][i][j]);
              if (p < 0 || utils.tauRand(random) < rho) {
                continue;
              }
              for (var k = 0; k < maxCandidates; k++) {
                var q = Math.floor(candidateNeighbors[0][i][k]);
                var cj = candidateNeighbors[2][i][j];
                var ck = candidateNeighbors[2][i][k];
                if (q < 0 || !cj && !ck) {
                  continue;
                }
                var d = distanceFn(data[p], data[q]);
                c += heap.heapPush(currentGraph, p, d, q, 1);
                c += heap.heapPush(currentGraph, q, d, p, 1);
              }
            }
          }
          if (c <= delta * nNeighbors * data.length) {
            break;
          }
        }
        var sorted = heap.deheapSort(currentGraph);
        return sorted;
      };
    }
    exports.makeNNDescent = makeNNDescent;
    function makeInitializations(distanceFn) {
      function initFromRandom(nNeighbors, data, queryPoints, _heap, random) {
        for (var i = 0; i < queryPoints.length; i++) {
          var indices = utils.rejectionSample(nNeighbors, data.length, random);
          for (var j = 0; j < indices.length; j++) {
            if (indices[j] < 0) {
              continue;
            }
            var d = distanceFn(data[indices[j]], queryPoints[i]);
            heap.heapPush(_heap, i, d, indices[j], 1);
          }
        }
      }
      function initFromTree(_tree, data, queryPoints, _heap, random) {
        for (var i = 0; i < queryPoints.length; i++) {
          var indices = tree.searchFlatTree(queryPoints[i], _tree, random);
          for (var j = 0; j < indices.length; j++) {
            if (indices[j] < 0) {
              return;
            }
            var d = distanceFn(data[indices[j]], queryPoints[i]);
            heap.heapPush(_heap, i, d, indices[j], 1);
          }
        }
        return;
      }
      return { initFromRandom, initFromTree };
    }
    exports.makeInitializations = makeInitializations;
    function makeInitializedNNSearch(distanceFn) {
      return function nnSearchFn(data, graph, initialization, queryPoints) {
        var e_1, _a;
        var _b = matrix.getCSR(graph), indices = _b.indices, indptr = _b.indptr;
        for (var i = 0; i < queryPoints.length; i++) {
          var tried = new Set(initialization[0][i]);
          while (true) {
            var vertex = heap.smallestFlagged(initialization, i);
            if (vertex === -1) {
              break;
            }
            var candidates = indices.slice(indptr[vertex], indptr[vertex + 1]);
            try {
              for (var candidates_1 = (e_1 = void 0, __values(candidates)), candidates_1_1 = candidates_1.next(); !candidates_1_1.done; candidates_1_1 = candidates_1.next()) {
                var candidate = candidates_1_1.value;
                if (candidate === vertex || candidate === -1 || tried.has(candidate)) {
                  continue;
                }
                var d = distanceFn(data[candidate], queryPoints[i]);
                heap.uncheckedHeapPush(initialization, i, d, candidate, 1);
                tried.add(candidate);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (candidates_1_1 && !candidates_1_1.done && (_a = candidates_1.return))
                  _a.call(candidates_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
        }
        return initialization;
      };
    }
    exports.makeInitializedNNSearch = makeInitializedNNSearch;
    function initializeSearch(forest, data, queryPoints, nNeighbors, initFromRandom, initFromTree, random) {
      var e_2, _a;
      var results = heap.makeHeap(queryPoints.length, nNeighbors);
      initFromRandom(nNeighbors, data, queryPoints, results, random);
      if (forest) {
        try {
          for (var forest_1 = __values(forest), forest_1_1 = forest_1.next(); !forest_1_1.done; forest_1_1 = forest_1.next()) {
            var tree_1 = forest_1_1.value;
            initFromTree(tree_1, data, queryPoints, results, random);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (forest_1_1 && !forest_1_1.done && (_a = forest_1.return))
              _a.call(forest_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
      return results;
    }
    exports.initializeSearch = initializeSearch;
  }
});

// node_modules/ml-levenberg-marquardt/node_modules/is-any-array/src/index.js
function isAnyArray(object) {
  return toString.call(object).endsWith("Array]");
}
var toString;
var init_src = __esm({
  "node_modules/ml-levenberg-marquardt/node_modules/is-any-array/src/index.js"() {
    toString = Object.prototype.toString;
  }
});

// node_modules/ml-levenberg-marquardt/src/errorCalculation.js
function errorCalculation(data, parameters, parameterizedFunction) {
  let error = 0;
  const func = parameterizedFunction(parameters);
  for (let i = 0; i < data.x.length; i++) {
    error += Math.abs(data.y[i] - func(data.x[i]));
  }
  return error;
}
var init_errorCalculation = __esm({
  "node_modules/ml-levenberg-marquardt/src/errorCalculation.js"() {
  }
});

// node_modules/ml-levenberg-marquardt/src/step.js
function gradientFunction(data, evaluatedData, params, gradientDifference, paramFunction) {
  const n = params.length;
  const m = data.x.length;
  let ans = new Array(n);
  for (let param = 0; param < n; param++) {
    ans[param] = new Array(m);
    let auxParams = params.slice();
    auxParams[param] += gradientDifference;
    let funcParam = paramFunction(auxParams);
    for (let point = 0; point < m; point++) {
      ans[param][point] = evaluatedData[point] - funcParam(data.x[point]);
    }
  }
  return new Matrix(ans);
}
function matrixFunction(data, evaluatedData) {
  const m = data.x.length;
  let ans = new Array(m);
  for (let point = 0; point < m; point++) {
    ans[point] = [data.y[point] - evaluatedData[point]];
  }
  return new Matrix(ans);
}
function step(data, params, damping, gradientDifference, parameterizedFunction) {
  let value = damping * gradientDifference * gradientDifference;
  let identity = Matrix.eye(params.length, params.length, value);
  const func = parameterizedFunction(params);
  let evaluatedData = new Float64Array(data.x.length);
  for (let i = 0; i < data.x.length; i++) {
    evaluatedData[i] = func(data.x[i]);
  }
  let gradientFunc = gradientFunction(
    data,
    evaluatedData,
    params,
    gradientDifference,
    parameterizedFunction
  );
  let matrixFunc = matrixFunction(data, evaluatedData);
  let inverseMatrix = inverse(
    identity.add(gradientFunc.mmul(gradientFunc.transpose()))
  );
  params = new Matrix([params]);
  params = params.sub(
    inverseMatrix.mmul(gradientFunc).mmul(matrixFunc).mul(gradientDifference).transpose()
  );
  return params.to1DArray();
}
var init_step = __esm({
  "node_modules/ml-levenberg-marquardt/src/step.js"() {
    init_matrix();
  }
});

// node_modules/ml-levenberg-marquardt/src/index.js
var src_exports = {};
__export(src_exports, {
  default: () => levenbergMarquardt
});
function levenbergMarquardt(data, parameterizedFunction, options = {}) {
  let {
    maxIterations = 100,
    gradientDifference = 0.1,
    damping = 0,
    errorTolerance = 0.01,
    minValues,
    maxValues,
    initialValues
  } = options;
  if (damping <= 0) {
    throw new Error("The damping option must be a positive number");
  } else if (!data.x || !data.y) {
    throw new Error("The data parameter must have x and y elements");
  } else if (!isAnyArray(data.x) || data.x.length < 2 || !isAnyArray(data.y) || data.y.length < 2) {
    throw new Error(
      "The data parameter elements must be an array with more than 2 points"
    );
  } else if (data.x.length !== data.y.length) {
    throw new Error("The data parameter elements must have the same size");
  }
  let parameters = initialValues || new Array(parameterizedFunction.length).fill(1);
  let parLen = parameters.length;
  maxValues = maxValues || new Array(parLen).fill(Number.MAX_SAFE_INTEGER);
  minValues = minValues || new Array(parLen).fill(Number.MIN_SAFE_INTEGER);
  if (maxValues.length !== minValues.length) {
    throw new Error("minValues and maxValues must be the same size");
  }
  if (!isAnyArray(parameters)) {
    throw new Error("initialValues must be an array");
  }
  let error = errorCalculation(data, parameters, parameterizedFunction);
  let converged = error <= errorTolerance;
  let iteration;
  for (iteration = 0; iteration < maxIterations && !converged; iteration++) {
    parameters = step(
      data,
      parameters,
      damping,
      gradientDifference,
      parameterizedFunction
    );
    for (let k = 0; k < parLen; k++) {
      parameters[k] = Math.min(
        Math.max(minValues[k], parameters[k]),
        maxValues[k]
      );
    }
    error = errorCalculation(data, parameters, parameterizedFunction);
    if (isNaN(error))
      break;
    converged = error <= errorTolerance;
  }
  return {
    parameterValues: parameters,
    parameterError: error,
    iterations: iteration
  };
}
var init_src2 = __esm({
  "node_modules/ml-levenberg-marquardt/src/index.js"() {
    init_src();
    init_errorCalculation();
    init_step();
  }
});

// node_modules/umap-js/dist/umap.js
var require_umap = __commonJS({
  "node_modules/umap-js/dist/umap.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step2(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step2(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step2(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step2((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step2([n, v]);
        };
      }
      function step2(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spread = exports && exports.__spread || function() {
      for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.initTransform = exports.resetLocalConnectivity = exports.fastIntersection = exports.findABParams = exports.cosine = exports.euclidean = exports.UMAP = void 0;
    var heap = __importStar(require_heap());
    var matrix = __importStar(require_matrix());
    var nnDescent = __importStar(require_nn_descent());
    var tree = __importStar(require_tree());
    var utils = __importStar(require_utils());
    var ml_levenberg_marquardt_1 = __importDefault((init_src2(), __toCommonJS(src_exports)));
    var SMOOTH_K_TOLERANCE = 1e-5;
    var MIN_K_DIST_SCALE = 1e-3;
    var UMAP = function() {
      function UMAP2(params) {
        var _this = this;
        if (params === void 0) {
          params = {};
        }
        this.learningRate = 1;
        this.localConnectivity = 1;
        this.minDist = 0.1;
        this.nComponents = 2;
        this.nEpochs = 0;
        this.nNeighbors = 15;
        this.negativeSampleRate = 5;
        this.random = Math.random;
        this.repulsionStrength = 1;
        this.setOpMixRatio = 1;
        this.spread = 1;
        this.transformQueueSize = 4;
        this.targetMetric = "categorical";
        this.targetWeight = 0.5;
        this.targetNNeighbors = this.nNeighbors;
        this.distanceFn = euclidean;
        this.isInitialized = false;
        this.rpForest = [];
        this.embedding = [];
        this.optimizationState = new OptimizationState();
        var setParam = function(key) {
          if (params[key] !== void 0)
            _this[key] = params[key];
        };
        setParam("distanceFn");
        setParam("learningRate");
        setParam("localConnectivity");
        setParam("minDist");
        setParam("nComponents");
        setParam("nEpochs");
        setParam("nNeighbors");
        setParam("negativeSampleRate");
        setParam("random");
        setParam("repulsionStrength");
        setParam("setOpMixRatio");
        setParam("spread");
        setParam("transformQueueSize");
      }
      UMAP2.prototype.fit = function(X) {
        this.initializeFit(X);
        this.optimizeLayout();
        return this.embedding;
      };
      UMAP2.prototype.fitAsync = function(X, callback) {
        if (callback === void 0) {
          callback = function() {
            return true;
          };
        }
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                this.initializeFit(X);
                return [4, this.optimizeLayoutAsync(callback)];
              case 1:
                _a.sent();
                return [2, this.embedding];
            }
          });
        });
      };
      UMAP2.prototype.setSupervisedProjection = function(Y, params) {
        if (params === void 0) {
          params = {};
        }
        this.Y = Y;
        this.targetMetric = params.targetMetric || this.targetMetric;
        this.targetWeight = params.targetWeight || this.targetWeight;
        this.targetNNeighbors = params.targetNNeighbors || this.targetNNeighbors;
      };
      UMAP2.prototype.setPrecomputedKNN = function(knnIndices, knnDistances) {
        this.knnIndices = knnIndices;
        this.knnDistances = knnDistances;
      };
      UMAP2.prototype.initializeFit = function(X) {
        if (X.length <= this.nNeighbors) {
          throw new Error("Not enough data points (" + X.length + ") to create nNeighbors: " + this.nNeighbors + ".  Add more data points or adjust the configuration.");
        }
        if (this.X === X && this.isInitialized) {
          return this.getNEpochs();
        }
        this.X = X;
        if (!this.knnIndices && !this.knnDistances) {
          var knnResults = this.nearestNeighbors(X);
          this.knnIndices = knnResults.knnIndices;
          this.knnDistances = knnResults.knnDistances;
        }
        this.graph = this.fuzzySimplicialSet(X, this.nNeighbors, this.setOpMixRatio);
        this.makeSearchFns();
        this.searchGraph = this.makeSearchGraph(X);
        this.processGraphForSupervisedProjection();
        var _a = this.initializeSimplicialSetEmbedding(), head = _a.head, tail = _a.tail, epochsPerSample = _a.epochsPerSample;
        this.optimizationState.head = head;
        this.optimizationState.tail = tail;
        this.optimizationState.epochsPerSample = epochsPerSample;
        this.initializeOptimization();
        this.prepareForOptimizationLoop();
        this.isInitialized = true;
        return this.getNEpochs();
      };
      UMAP2.prototype.makeSearchFns = function() {
        var _a = nnDescent.makeInitializations(this.distanceFn), initFromTree = _a.initFromTree, initFromRandom = _a.initFromRandom;
        this.initFromTree = initFromTree;
        this.initFromRandom = initFromRandom;
        this.search = nnDescent.makeInitializedNNSearch(this.distanceFn);
      };
      UMAP2.prototype.makeSearchGraph = function(X) {
        var knnIndices = this.knnIndices;
        var knnDistances = this.knnDistances;
        var dims = [X.length, X.length];
        var searchGraph = new matrix.SparseMatrix([], [], [], dims);
        for (var i = 0; i < knnIndices.length; i++) {
          var knn = knnIndices[i];
          var distances = knnDistances[i];
          for (var j = 0; j < knn.length; j++) {
            var neighbor = knn[j];
            var distance = distances[j];
            if (distance > 0) {
              searchGraph.set(i, neighbor, distance);
            }
          }
        }
        var transpose = matrix.transpose(searchGraph);
        return matrix.maximum(searchGraph, transpose);
      };
      UMAP2.prototype.transform = function(toTransform) {
        var _this = this;
        var rawData = this.X;
        if (rawData === void 0 || rawData.length === 0) {
          throw new Error("No data has been fit.");
        }
        var nNeighbors = Math.floor(this.nNeighbors * this.transformQueueSize);
        nNeighbors = Math.min(rawData.length, nNeighbors);
        var init = nnDescent.initializeSearch(this.rpForest, rawData, toTransform, nNeighbors, this.initFromRandom, this.initFromTree, this.random);
        var result = this.search(rawData, this.searchGraph, init, toTransform);
        var _a = heap.deheapSort(result), indices = _a.indices, distances = _a.weights;
        indices = indices.map(function(x) {
          return x.slice(0, _this.nNeighbors);
        });
        distances = distances.map(function(x) {
          return x.slice(0, _this.nNeighbors);
        });
        var adjustedLocalConnectivity = Math.max(0, this.localConnectivity - 1);
        var _b = this.smoothKNNDistance(distances, this.nNeighbors, adjustedLocalConnectivity), sigmas = _b.sigmas, rhos = _b.rhos;
        var _c = this.computeMembershipStrengths(indices, distances, sigmas, rhos), rows = _c.rows, cols = _c.cols, vals = _c.vals;
        var size = [toTransform.length, rawData.length];
        var graph = new matrix.SparseMatrix(rows, cols, vals, size);
        var normed = matrix.normalize(graph, "l1");
        var csrMatrix = matrix.getCSR(normed);
        var nPoints = toTransform.length;
        var eIndices = utils.reshape2d(csrMatrix.indices, nPoints, this.nNeighbors);
        var eWeights = utils.reshape2d(csrMatrix.values, nPoints, this.nNeighbors);
        var embedding = initTransform(eIndices, eWeights, this.embedding);
        var nEpochs = this.nEpochs ? this.nEpochs / 3 : graph.nRows <= 1e4 ? 100 : 30;
        var graphMax = graph.getValues().reduce(function(max, val) {
          return val > max ? val : max;
        }, 0);
        graph = graph.map(function(value) {
          return value < graphMax / nEpochs ? 0 : value;
        });
        graph = matrix.eliminateZeros(graph);
        var epochsPerSample = this.makeEpochsPerSample(graph.getValues(), nEpochs);
        var head = graph.getRows();
        var tail = graph.getCols();
        this.assignOptimizationStateParameters({
          headEmbedding: embedding,
          tailEmbedding: this.embedding,
          head,
          tail,
          currentEpoch: 0,
          nEpochs,
          nVertices: graph.getDims()[1],
          epochsPerSample
        });
        this.prepareForOptimizationLoop();
        return this.optimizeLayout();
      };
      UMAP2.prototype.processGraphForSupervisedProjection = function() {
        var _a = this, Y = _a.Y, X = _a.X;
        if (Y) {
          if (Y.length !== X.length) {
            throw new Error("Length of X and y must be equal");
          }
          if (this.targetMetric === "categorical") {
            var lt = this.targetWeight < 1;
            var farDist = lt ? 2.5 * (1 / (1 - this.targetWeight)) : 1e12;
            this.graph = this.categoricalSimplicialSetIntersection(this.graph, Y, farDist);
          }
        }
      };
      UMAP2.prototype.step = function() {
        var currentEpoch = this.optimizationState.currentEpoch;
        if (currentEpoch < this.getNEpochs()) {
          this.optimizeLayoutStep(currentEpoch);
        }
        return this.optimizationState.currentEpoch;
      };
      UMAP2.prototype.getEmbedding = function() {
        return this.embedding;
      };
      UMAP2.prototype.nearestNeighbors = function(X) {
        var _a = this, distanceFn = _a.distanceFn, nNeighbors = _a.nNeighbors;
        var log2 = function(n) {
          return Math.log(n) / Math.log(2);
        };
        var metricNNDescent = nnDescent.makeNNDescent(distanceFn, this.random);
        var round = function(n) {
          return n === 0.5 ? 0 : Math.round(n);
        };
        var nTrees = 5 + Math.floor(round(Math.pow(X.length, 0.5) / 20));
        var nIters = Math.max(5, Math.floor(Math.round(log2(X.length))));
        this.rpForest = tree.makeForest(X, nNeighbors, nTrees, this.random);
        var leafArray = tree.makeLeafArray(this.rpForest);
        var _b = metricNNDescent(X, leafArray, nNeighbors, nIters), indices = _b.indices, weights = _b.weights;
        return { knnIndices: indices, knnDistances: weights };
      };
      UMAP2.prototype.fuzzySimplicialSet = function(X, nNeighbors, setOpMixRatio) {
        if (setOpMixRatio === void 0) {
          setOpMixRatio = 1;
        }
        var _a = this, _b = _a.knnIndices, knnIndices = _b === void 0 ? [] : _b, _c = _a.knnDistances, knnDistances = _c === void 0 ? [] : _c, localConnectivity = _a.localConnectivity;
        var _d = this.smoothKNNDistance(knnDistances, nNeighbors, localConnectivity), sigmas = _d.sigmas, rhos = _d.rhos;
        var _e = this.computeMembershipStrengths(knnIndices, knnDistances, sigmas, rhos), rows = _e.rows, cols = _e.cols, vals = _e.vals;
        var size = [X.length, X.length];
        var sparseMatrix = new matrix.SparseMatrix(rows, cols, vals, size);
        var transpose = matrix.transpose(sparseMatrix);
        var prodMatrix = matrix.pairwiseMultiply(sparseMatrix, transpose);
        var a = matrix.subtract(matrix.add(sparseMatrix, transpose), prodMatrix);
        var b = matrix.multiplyScalar(a, setOpMixRatio);
        var c = matrix.multiplyScalar(prodMatrix, 1 - setOpMixRatio);
        var result = matrix.add(b, c);
        return result;
      };
      UMAP2.prototype.categoricalSimplicialSetIntersection = function(simplicialSet, target, farDist, unknownDist) {
        if (unknownDist === void 0) {
          unknownDist = 1;
        }
        var intersection = fastIntersection(simplicialSet, target, unknownDist, farDist);
        intersection = matrix.eliminateZeros(intersection);
        return resetLocalConnectivity(intersection);
      };
      UMAP2.prototype.smoothKNNDistance = function(distances, k, localConnectivity, nIter, bandwidth) {
        if (localConnectivity === void 0) {
          localConnectivity = 1;
        }
        if (nIter === void 0) {
          nIter = 64;
        }
        if (bandwidth === void 0) {
          bandwidth = 1;
        }
        var target = Math.log(k) / Math.log(2) * bandwidth;
        var rho = utils.zeros(distances.length);
        var result = utils.zeros(distances.length);
        for (var i = 0; i < distances.length; i++) {
          var lo = 0;
          var hi = Infinity;
          var mid = 1;
          var ithDistances = distances[i];
          var nonZeroDists = ithDistances.filter(function(d2) {
            return d2 > 0;
          });
          if (nonZeroDists.length >= localConnectivity) {
            var index = Math.floor(localConnectivity);
            var interpolation = localConnectivity - index;
            if (index > 0) {
              rho[i] = nonZeroDists[index - 1];
              if (interpolation > SMOOTH_K_TOLERANCE) {
                rho[i] += interpolation * (nonZeroDists[index] - nonZeroDists[index - 1]);
              }
            } else {
              rho[i] = interpolation * nonZeroDists[0];
            }
          } else if (nonZeroDists.length > 0) {
            rho[i] = utils.max(nonZeroDists);
          }
          for (var n = 0; n < nIter; n++) {
            var psum = 0;
            for (var j = 1; j < distances[i].length; j++) {
              var d = distances[i][j] - rho[i];
              if (d > 0) {
                psum += Math.exp(-(d / mid));
              } else {
                psum += 1;
              }
            }
            if (Math.abs(psum - target) < SMOOTH_K_TOLERANCE) {
              break;
            }
            if (psum > target) {
              hi = mid;
              mid = (lo + hi) / 2;
            } else {
              lo = mid;
              if (hi === Infinity) {
                mid *= 2;
              } else {
                mid = (lo + hi) / 2;
              }
            }
          }
          result[i] = mid;
          if (rho[i] > 0) {
            var meanIthDistances = utils.mean(ithDistances);
            if (result[i] < MIN_K_DIST_SCALE * meanIthDistances) {
              result[i] = MIN_K_DIST_SCALE * meanIthDistances;
            }
          } else {
            var meanDistances = utils.mean(distances.map(utils.mean));
            if (result[i] < MIN_K_DIST_SCALE * meanDistances) {
              result[i] = MIN_K_DIST_SCALE * meanDistances;
            }
          }
        }
        return { sigmas: result, rhos: rho };
      };
      UMAP2.prototype.computeMembershipStrengths = function(knnIndices, knnDistances, sigmas, rhos) {
        var nSamples = knnIndices.length;
        var nNeighbors = knnIndices[0].length;
        var rows = utils.zeros(nSamples * nNeighbors);
        var cols = utils.zeros(nSamples * nNeighbors);
        var vals = utils.zeros(nSamples * nNeighbors);
        for (var i = 0; i < nSamples; i++) {
          for (var j = 0; j < nNeighbors; j++) {
            var val = 0;
            if (knnIndices[i][j] === -1) {
              continue;
            }
            if (knnIndices[i][j] === i) {
              val = 0;
            } else if (knnDistances[i][j] - rhos[i] <= 0) {
              val = 1;
            } else {
              val = Math.exp(-((knnDistances[i][j] - rhos[i]) / sigmas[i]));
            }
            rows[i * nNeighbors + j] = i;
            cols[i * nNeighbors + j] = knnIndices[i][j];
            vals[i * nNeighbors + j] = val;
          }
        }
        return { rows, cols, vals };
      };
      UMAP2.prototype.initializeSimplicialSetEmbedding = function() {
        var _this = this;
        var nEpochs = this.getNEpochs();
        var nComponents = this.nComponents;
        var graphValues = this.graph.getValues();
        var graphMax = 0;
        for (var i = 0; i < graphValues.length; i++) {
          var value = graphValues[i];
          if (graphMax < graphValues[i]) {
            graphMax = value;
          }
        }
        var graph = this.graph.map(function(value2) {
          if (value2 < graphMax / nEpochs) {
            return 0;
          } else {
            return value2;
          }
        });
        this.embedding = utils.zeros(graph.nRows).map(function() {
          return utils.zeros(nComponents).map(function() {
            return utils.tauRand(_this.random) * 20 + -10;
          });
        });
        var weights = [];
        var head = [];
        var tail = [];
        var rowColValues = graph.getAll();
        for (var i = 0; i < rowColValues.length; i++) {
          var entry = rowColValues[i];
          if (entry.value) {
            weights.push(entry.value);
            tail.push(entry.row);
            head.push(entry.col);
          }
        }
        var epochsPerSample = this.makeEpochsPerSample(weights, nEpochs);
        return { head, tail, epochsPerSample };
      };
      UMAP2.prototype.makeEpochsPerSample = function(weights, nEpochs) {
        var result = utils.filled(weights.length, -1);
        var max = utils.max(weights);
        var nSamples = weights.map(function(w) {
          return w / max * nEpochs;
        });
        nSamples.forEach(function(n, i) {
          if (n > 0)
            result[i] = nEpochs / nSamples[i];
        });
        return result;
      };
      UMAP2.prototype.assignOptimizationStateParameters = function(state) {
        Object.assign(this.optimizationState, state);
      };
      UMAP2.prototype.prepareForOptimizationLoop = function() {
        var _a = this, repulsionStrength = _a.repulsionStrength, learningRate = _a.learningRate, negativeSampleRate = _a.negativeSampleRate;
        var _b = this.optimizationState, epochsPerSample = _b.epochsPerSample, headEmbedding = _b.headEmbedding, tailEmbedding = _b.tailEmbedding;
        var dim = headEmbedding[0].length;
        var moveOther = headEmbedding.length === tailEmbedding.length;
        var epochsPerNegativeSample = epochsPerSample.map(function(e) {
          return e / negativeSampleRate;
        });
        var epochOfNextNegativeSample = __spread(epochsPerNegativeSample);
        var epochOfNextSample = __spread(epochsPerSample);
        this.assignOptimizationStateParameters({
          epochOfNextSample,
          epochOfNextNegativeSample,
          epochsPerNegativeSample,
          moveOther,
          initialAlpha: learningRate,
          alpha: learningRate,
          gamma: repulsionStrength,
          dim
        });
      };
      UMAP2.prototype.initializeOptimization = function() {
        var headEmbedding = this.embedding;
        var tailEmbedding = this.embedding;
        var _a = this.optimizationState, head = _a.head, tail = _a.tail, epochsPerSample = _a.epochsPerSample;
        var nEpochs = this.getNEpochs();
        var nVertices = this.graph.nCols;
        var _b = findABParams(this.spread, this.minDist), a = _b.a, b = _b.b;
        this.assignOptimizationStateParameters({
          headEmbedding,
          tailEmbedding,
          head,
          tail,
          epochsPerSample,
          a,
          b,
          nEpochs,
          nVertices
        });
      };
      UMAP2.prototype.optimizeLayoutStep = function(n) {
        var optimizationState = this.optimizationState;
        var head = optimizationState.head, tail = optimizationState.tail, headEmbedding = optimizationState.headEmbedding, tailEmbedding = optimizationState.tailEmbedding, epochsPerSample = optimizationState.epochsPerSample, epochOfNextSample = optimizationState.epochOfNextSample, epochOfNextNegativeSample = optimizationState.epochOfNextNegativeSample, epochsPerNegativeSample = optimizationState.epochsPerNegativeSample, moveOther = optimizationState.moveOther, initialAlpha = optimizationState.initialAlpha, alpha = optimizationState.alpha, gamma = optimizationState.gamma, a = optimizationState.a, b = optimizationState.b, dim = optimizationState.dim, nEpochs = optimizationState.nEpochs, nVertices = optimizationState.nVertices;
        var clipValue = 4;
        for (var i = 0; i < epochsPerSample.length; i++) {
          if (epochOfNextSample[i] > n) {
            continue;
          }
          var j = head[i];
          var k = tail[i];
          var current = headEmbedding[j];
          var other = tailEmbedding[k];
          var distSquared = rDist(current, other);
          var gradCoeff = 0;
          if (distSquared > 0) {
            gradCoeff = -2 * a * b * Math.pow(distSquared, b - 1);
            gradCoeff /= a * Math.pow(distSquared, b) + 1;
          }
          for (var d = 0; d < dim; d++) {
            var gradD = clip(gradCoeff * (current[d] - other[d]), clipValue);
            current[d] += gradD * alpha;
            if (moveOther) {
              other[d] += -gradD * alpha;
            }
          }
          epochOfNextSample[i] += epochsPerSample[i];
          var nNegSamples = Math.floor((n - epochOfNextNegativeSample[i]) / epochsPerNegativeSample[i]);
          for (var p = 0; p < nNegSamples; p++) {
            var k_1 = utils.tauRandInt(nVertices, this.random);
            var other_1 = tailEmbedding[k_1];
            var distSquared_1 = rDist(current, other_1);
            var gradCoeff_1 = 0;
            if (distSquared_1 > 0) {
              gradCoeff_1 = 2 * gamma * b;
              gradCoeff_1 /= (1e-3 + distSquared_1) * (a * Math.pow(distSquared_1, b) + 1);
            } else if (j === k_1) {
              continue;
            }
            for (var d = 0; d < dim; d++) {
              var gradD = 4;
              if (gradCoeff_1 > 0) {
                gradD = clip(gradCoeff_1 * (current[d] - other_1[d]), clipValue);
              }
              current[d] += gradD * alpha;
            }
          }
          epochOfNextNegativeSample[i] += nNegSamples * epochsPerNegativeSample[i];
        }
        optimizationState.alpha = initialAlpha * (1 - n / nEpochs);
        optimizationState.currentEpoch += 1;
        return headEmbedding;
      };
      UMAP2.prototype.optimizeLayoutAsync = function(epochCallback) {
        var _this = this;
        if (epochCallback === void 0) {
          epochCallback = function() {
            return true;
          };
        }
        return new Promise(function(resolve, reject) {
          var step2 = function() {
            return __awaiter(_this, void 0, void 0, function() {
              var _a, nEpochs, currentEpoch, epochCompleted, shouldStop, isFinished;
              return __generator(this, function(_b) {
                try {
                  _a = this.optimizationState, nEpochs = _a.nEpochs, currentEpoch = _a.currentEpoch;
                  this.embedding = this.optimizeLayoutStep(currentEpoch);
                  epochCompleted = this.optimizationState.currentEpoch;
                  shouldStop = epochCallback(epochCompleted) === false;
                  isFinished = epochCompleted === nEpochs;
                  if (!shouldStop && !isFinished) {
                    setTimeout(function() {
                      return step2();
                    }, 0);
                  } else {
                    return [2, resolve(isFinished)];
                  }
                } catch (err) {
                  reject(err);
                }
                return [2];
              });
            });
          };
          setTimeout(function() {
            return step2();
          }, 0);
        });
      };
      UMAP2.prototype.optimizeLayout = function(epochCallback) {
        if (epochCallback === void 0) {
          epochCallback = function() {
            return true;
          };
        }
        var isFinished = false;
        var embedding = [];
        while (!isFinished) {
          var _a = this.optimizationState, nEpochs = _a.nEpochs, currentEpoch = _a.currentEpoch;
          embedding = this.optimizeLayoutStep(currentEpoch);
          var epochCompleted = this.optimizationState.currentEpoch;
          var shouldStop = epochCallback(epochCompleted) === false;
          isFinished = epochCompleted === nEpochs || shouldStop;
        }
        return embedding;
      };
      UMAP2.prototype.getNEpochs = function() {
        var graph = this.graph;
        if (this.nEpochs > 0) {
          return this.nEpochs;
        }
        var length = graph.nRows;
        if (length <= 2500) {
          return 500;
        } else if (length <= 5e3) {
          return 400;
        } else if (length <= 7500) {
          return 300;
        } else {
          return 200;
        }
      };
      return UMAP2;
    }();
    exports.UMAP = UMAP;
    function euclidean(x, y) {
      var result = 0;
      for (var i = 0; i < x.length; i++) {
        result += Math.pow(x[i] - y[i], 2);
      }
      return Math.sqrt(result);
    }
    exports.euclidean = euclidean;
    function cosine(x, y) {
      var result = 0;
      var normX = 0;
      var normY = 0;
      for (var i = 0; i < x.length; i++) {
        result += x[i] * y[i];
        normX += Math.pow(x[i], 2);
        normY += Math.pow(y[i], 2);
      }
      if (normX === 0 && normY === 0) {
        return 0;
      } else if (normX === 0 || normY === 0) {
        return 1;
      } else {
        return 1 - result / Math.sqrt(normX * normY);
      }
    }
    exports.cosine = cosine;
    var OptimizationState = function() {
      function OptimizationState2() {
        this.currentEpoch = 0;
        this.headEmbedding = [];
        this.tailEmbedding = [];
        this.head = [];
        this.tail = [];
        this.epochsPerSample = [];
        this.epochOfNextSample = [];
        this.epochOfNextNegativeSample = [];
        this.epochsPerNegativeSample = [];
        this.moveOther = true;
        this.initialAlpha = 1;
        this.alpha = 1;
        this.gamma = 1;
        this.a = 1.5769434603113077;
        this.b = 0.8950608779109733;
        this.dim = 2;
        this.nEpochs = 500;
        this.nVertices = 0;
      }
      return OptimizationState2;
    }();
    function clip(x, clipValue) {
      if (x > clipValue)
        return clipValue;
      else if (x < -clipValue)
        return -clipValue;
      else
        return x;
    }
    function rDist(x, y) {
      var result = 0;
      for (var i = 0; i < x.length; i++) {
        result += Math.pow(x[i] - y[i], 2);
      }
      return result;
    }
    function findABParams(spread, minDist) {
      var curve = function(_a2) {
        var _b = __read(_a2, 2), a2 = _b[0], b2 = _b[1];
        return function(x) {
          return 1 / (1 + a2 * Math.pow(x, 2 * b2));
        };
      };
      var xv = utils.linear(0, spread * 3, 300).map(function(val) {
        return val < minDist ? 1 : val;
      });
      var yv = utils.zeros(xv.length).map(function(val, index) {
        var gte = xv[index] >= minDist;
        return gte ? Math.exp(-(xv[index] - minDist) / spread) : val;
      });
      var initialValues = [0.5, 0.5];
      var data = { x: xv, y: yv };
      var options = {
        damping: 1.5,
        initialValues,
        gradientDifference: 0.1,
        maxIterations: 100,
        errorTolerance: 0.01
      };
      var parameterValues = ml_levenberg_marquardt_1.default(data, curve, options).parameterValues;
      var _a = __read(parameterValues, 2), a = _a[0], b = _a[1];
      return { a, b };
    }
    exports.findABParams = findABParams;
    function fastIntersection(graph, target, unknownDist, farDist) {
      if (unknownDist === void 0) {
        unknownDist = 1;
      }
      if (farDist === void 0) {
        farDist = 5;
      }
      return graph.map(function(value, row, col) {
        if (target[row] === -1 || target[col] === -1) {
          return value * Math.exp(-unknownDist);
        } else if (target[row] !== target[col]) {
          return value * Math.exp(-farDist);
        } else {
          return value;
        }
      });
    }
    exports.fastIntersection = fastIntersection;
    function resetLocalConnectivity(simplicialSet) {
      simplicialSet = matrix.normalize(simplicialSet, "max");
      var transpose = matrix.transpose(simplicialSet);
      var prodMatrix = matrix.pairwiseMultiply(transpose, simplicialSet);
      simplicialSet = matrix.add(simplicialSet, matrix.subtract(transpose, prodMatrix));
      return matrix.eliminateZeros(simplicialSet);
    }
    exports.resetLocalConnectivity = resetLocalConnectivity;
    function initTransform(indices, weights, embedding) {
      var result = utils.zeros(indices.length).map(function(z) {
        return utils.zeros(embedding[0].length);
      });
      for (var i = 0; i < indices.length; i++) {
        for (var j = 0; j < indices[0].length; j++) {
          for (var d = 0; d < embedding[0].length; d++) {
            var a = indices[i][j];
            result[i][d] += weights[i][j] * embedding[a][d];
          }
        }
      }
      return result;
    }
    exports.initTransform = initTransform;
  }
});

// node_modules/umap-js/dist/index.js
var require_dist = __commonJS({
  "node_modules/umap-js/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var umap_1 = require_umap();
    Object.defineProperty(exports, "UMAP", { enumerable: true, get: function() {
      return umap_1.UMAP;
    } });
  }
});
export default require_dist();
//# sourceMappingURL=umap-js.js.map
