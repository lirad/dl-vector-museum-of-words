{
  "version": 3,
  "sources": ["../../ml-pca/src/pca.ts"],
  "sourcesContent": ["import {\n  Matrix,\n  MatrixTransposeView,\n  EVD,\n  SVD,\n  NIPALS,\n  AbstractMatrix,\n} from 'ml-matrix';\n\ntype MaybeMatrix = AbstractMatrix | number[][];\n\nexport interface PCAOptions {\n  isCovarianceMatrix?: boolean;\n  method?: 'SVD' | 'NIPALS' | 'covarianceMatrix';\n  center?: boolean;\n  scale?: boolean;\n  nCompNIPALS?: number;\n  ignoreZeroVariance?: boolean;\n}\n\nexport interface PCAModel {\n  name: 'PCA';\n  center: boolean;\n  scale: boolean;\n  means: number[];\n  stdevs: number[];\n  U: Matrix;\n  S: number[];\n  R?: any;\n  excludedFeatures?: number[];\n}\n\nexport interface PredictOptions {\n  nComponents?: number;\n}\n\n/**\n * Creates new PCA (Principal Component Analysis) from the dataset\n * @param {MaybeMatrix} dataset - dataset or covariance matrix.\n * @param {PCAOptions} [options]\n * @param {boolean} [options.isCovarianceMatrix=false] - true if the dataset is a covariance matrix.\n * @param {string} [options.method='SVD'] - select which method to use: SVD (default), covarianceMatrirx or NIPALS.\n * @param {number} [options.nCompNIPALS=2] - number of components to be computed with NIPALS.\n * @param {boolean} [options.center=true] - should the data be centered (subtract the mean).\n * @param {boolean} [options.scale=false] - should the data be scaled (divide by the standard deviation).\n * @param {boolean} [options.ignoreZeroVariance=false] - ignore columns with zero variance if `scale` is `true`.\n * */\nexport class PCA {\n  private center: boolean;\n  private scale: boolean;\n  private excludedFeatures: number[];\n  /* eslint-disable @typescript-eslint/naming-convention */\n  private U: Matrix | null = null;\n  private S: number[] | null = null;\n  private R: any;\n  private means: number[] | null;\n  private stdevs: number[] | null;\n\n  public constructor(\n    dataset?: MaybeMatrix,\n    options: PCAOptions = {},\n    model?: PCAModel,\n  ) {\n    if (model) {\n      this.center = model.center;\n      this.scale = model.scale;\n      this.means = model.means;\n      this.stdevs = model.stdevs;\n      this.U = Matrix.checkMatrix(model.U);\n      this.S = model.S;\n      this.R = model.R;\n      this.excludedFeatures = model.excludedFeatures || [];\n      return;\n    }\n    let datasetMatrix: Matrix;\n    if (Array.isArray(dataset)) {\n      datasetMatrix = new Matrix(dataset);\n    } else {\n      datasetMatrix = new Matrix(dataset as Matrix);\n    }\n\n    const {\n      isCovarianceMatrix = false,\n      method = 'SVD',\n      nCompNIPALS = 2,\n      center = true,\n      scale = false,\n      ignoreZeroVariance = false,\n    } = options;\n\n    this.center = center;\n    this.scale = scale;\n    this.means = null;\n    this.stdevs = null;\n    this.excludedFeatures = [];\n\n    if (isCovarianceMatrix) {\n      // User provided a covariance matrix instead of dataset.\n      this._computeFromCovarianceMatrix(datasetMatrix);\n      return;\n    }\n\n    this._adjust(datasetMatrix, ignoreZeroVariance);\n    switch (method) {\n      case 'covarianceMatrix': {\n        // User provided a dataset but wants us to compute and use the covariance matrix.\n        const covarianceMatrix = new MatrixTransposeView(datasetMatrix)\n          .mmul(datasetMatrix)\n          .div(datasetMatrix.rows - 1);\n        this._computeFromCovarianceMatrix(covarianceMatrix);\n        break;\n      }\n      case 'NIPALS': {\n        this._computeWithNIPALS(datasetMatrix, nCompNIPALS);\n        break;\n      }\n      case 'SVD': {\n        const svd = new SVD(datasetMatrix, {\n          computeLeftSingularVectors: false,\n          computeRightSingularVectors: true,\n          autoTranspose: true,\n        });\n\n        this.U = svd.rightSingularVectors;\n\n        const singularValues = svd.diagonal;\n        const eigenvalues: number[] = [];\n        for (const singularValue of singularValues) {\n          eigenvalues.push(\n            (singularValue * singularValue) / (datasetMatrix.rows - 1),\n          );\n        }\n        this.S = eigenvalues;\n        break;\n      }\n      default: {\n        throw new Error(`unknown method: ${method as string}`);\n      }\n    }\n  }\n\n  /**\n   * Load a PCA model from JSON\n   * @param {PCAModel} model\n   * @return {PCA}\n   */\n  public static load(model: PCAModel): PCA {\n    if (typeof model.name !== 'string') {\n      throw new TypeError('model must have a name property');\n    }\n    if (model.name !== 'PCA') {\n      throw new RangeError(`invalid model: ${model.name as string}`);\n    }\n    return new PCA(undefined, undefined, model);\n  }\n\n  /**\n   * Project the dataset into the PCA space\n   * @param {MaybeMatrix} dataset\n   * @param {PredictOptions} options\n   * @return {Matrix} dataset projected in the PCA space\n   */\n  public predict(dataset: MaybeMatrix, options: PredictOptions = {}): Matrix {\n    const { nComponents = (this.U as Matrix).columns } = options;\n    let datasetmatrix;\n    if (Array.isArray(dataset)) {\n      datasetmatrix = new Matrix(dataset);\n    } else {\n      datasetmatrix = new Matrix(dataset);\n    }\n    if (this.center) {\n      datasetmatrix.subRowVector(this.means as number[]);\n      if (this.scale) {\n        for (let i of this.excludedFeatures) {\n          datasetmatrix.removeColumn(i);\n        }\n        datasetmatrix.divRowVector(this.stdevs as number[]);\n      }\n    }\n    let predictions = datasetmatrix.mmul(this.U as Matrix);\n    return predictions.subMatrix(0, predictions.rows - 1, 0, nComponents - 1);\n  }\n\n  /**\n   * Calculates the inverse PCA transform\n   * @param {Matrix} dataset\n   * @return {Matrix} dataset projected in the PCA space\n   */\n  public invert(dataset: Matrix): Matrix {\n    dataset = Matrix.checkMatrix(dataset);\n\n    let inverse = dataset.mmul((this.U as Matrix).transpose());\n\n    if (this.center) {\n      if (this.scale) {\n        inverse.mulRowVector(this.stdevs as number[]);\n      }\n      inverse.addRowVector(this.means as number[]);\n    }\n\n    return inverse;\n  }\n\n  /**\n   * Returns the proportion of variance for each component\n   * @return {[number]}\n   */\n  public getExplainedVariance(): number[] {\n    let sum = 0;\n    if (this.S) {\n      for (const s of this.S) {\n        sum += s;\n      }\n    }\n    if (this.S) {\n      return this.S.map((value) => value / sum);\n    }\n    return [];\n  }\n\n  /**\n   * Returns the cumulative proportion of variance\n   * @return {[number]}\n   */\n  public getCumulativeVariance(): number[] {\n    let explained = this.getExplainedVariance();\n    for (let i = 1; i < explained.length; i++) {\n      explained[i] += explained[i - 1];\n    }\n    return explained;\n  }\n\n  /**\n   * Returns the Eigenvectors of the covariance matrix\n   * @returns {Matrix}\n   */\n  public getEigenvectors(): Matrix {\n    return this.U as Matrix;\n  }\n\n  /**\n   * Returns the Eigenvalues (on the diagonal)\n   * @returns {[number]}\n   */\n  public getEigenvalues(): number[] {\n    return this.S as number[];\n  }\n\n  /**\n   * Returns the standard deviations of the principal components\n   * @returns {[number]}\n   */\n  public getStandardDeviations(): number[] {\n    return (this.S as number[]).map((x) => Math.sqrt(x));\n  }\n\n  /**\n   * Returns the loadings matrix\n   * @return {Matrix}\n   */\n  public getLoadings(): Matrix {\n    return (this.U as Matrix).transpose();\n  }\n\n  /**\n   * Export the current model to a JSON object\n   * @return {Object} model\n   */\n  public toJSON(): PCAModel {\n    return {\n      name: 'PCA',\n      center: this.center,\n      scale: this.scale,\n      means: this.means as number[],\n      stdevs: this.stdevs as number[],\n      U: this.U as Matrix,\n      S: this.S as number[],\n      excludedFeatures: this.excludedFeatures,\n    };\n  }\n\n  private _adjust(dataset: Matrix, ignoreZeroVariance: boolean) {\n    if (this.center) {\n      const mean = dataset.mean('column');\n      const stdevs = this.scale\n        ? dataset.standardDeviation('column', { mean })\n        : null;\n      this.means = mean;\n      dataset.subRowVector(mean);\n      if (this.scale) {\n        for (let i = 0; i < (stdevs as number[]).length; i++) {\n          if ((stdevs as number[])[i] === 0) {\n            if (ignoreZeroVariance) {\n              dataset.removeColumn(i);\n              (stdevs as number[]).splice(i, 1);\n              this.excludedFeatures.push(i);\n              i--;\n            } else {\n              throw new RangeError(\n                `Cannot scale the dataset (standard deviation is zero at index ${i}`,\n              );\n            }\n          }\n        }\n        this.stdevs = stdevs;\n        dataset.divRowVector(stdevs as number[]);\n      }\n    }\n  }\n\n  private _computeFromCovarianceMatrix(dataset: MaybeMatrix) {\n    const evd = new EVD(dataset as number[][], { assumeSymmetric: true });\n    this.U = evd.eigenvectorMatrix;\n    this.U.flipRows();\n    this.S = evd.realEigenvalues;\n    this.S.reverse();\n  }\n\n  private _computeWithNIPALS(dataset: Matrix, nCompNIPALS: number) {\n    this.U = new Matrix(nCompNIPALS, dataset.columns);\n    this.S = [];\n\n    let x = dataset;\n    for (let i = 0; i < nCompNIPALS; i++) {\n      let dc = new NIPALS(x);\n\n      this.U.setRow(i, dc.w.transpose());\n      this.S.push(Math.pow(dc.s.get(0, 0), 2));\n\n      x = dc.xResidual;\n    }\n    this.U = this.U.transpose(); // to be compatible with API\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
